<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>mrpack → target-version checker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bar: #4f46e5; --bar-bg:#e5e7eb; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; padding: 1rem; }
    label,input,button,select { font-size: 1rem; }
    .controls { display:flex; gap:1rem; align-items:center; flex-wrap: wrap; }
    .muted { color:#666; }
    h2 { margin: 1.5rem 0 .5rem; font-size: 1.2rem; }
    table { border-collapse: collapse; margin-top: .5rem; width: 100%; }
    th, td { border: 1px solid #ddd; padding: .5rem; text-align: left; vertical-align: top; }
    th { background: #f6f6f6; }
    .ok { color: #157347; }
    .no { color: #b02a37; }
    pre { white-space: pre-wrap; }
    .bar { height: 10px; background: var(--bar-bg); border-radius: 999px; overflow: hidden; margin-top:.25rem; }
    .bar > span { display:block; height:100%; width:0%; background: var(--bar); transition: width .15s linear; }
    .status { display:flex; align-items:center; gap:.5rem; margin-top:.5rem; }
    .status small { color:#555; }
    .counts { font-size:.95rem; color:#333; }
    .badge { display:inline-block; padding:.125rem .4rem; border-radius:.45rem; font-size:.8rem; line-height:1; border:1px solid #ddd; background:#fafafa; color:#333; }
    .badge.modrinth { border-color:#d1fae5; background:#ecfdf5; color:#065f46; }
    .badge.github-fallback { border-color:#fde68a; background:#fffbeb; color:#92400e; }
    .builder { margin-top: 1rem; display:flex; gap:.75rem; align-items:center; flex-wrap:wrap; }
    .warn { color:#92400e; }
    .small { font-size:.9rem; }
  </style>
</head>
<body>
  <h1>Modrinth mrpack → version availability</h1>

  <div class="controls">
    <div>
      <label for="file">mrpack/zip:&nbsp;</label>
      <input type="file" id="file" accept=".mrpack,.zip" />
    </div>
    <div>
      <label for="mc">Target MC:&nbsp;</label>
      <select id="mc" disabled><option>Loading…</option></select>
    </div>
    <div>
      <label for="loader">Loader:&nbsp;</label>
      <select id="loader">
        <option value="fabric" selected>fabric</option>
        <option value="quilt">quilt</option>
        <option value="forge">forge</option>
        <option value="neoforge">neoforge</option>
      </select>
      <span class="muted">(* resource packs & shaders use loader “minecraft”)</span>
    </div>
    <button id="run">Check</button>
  </div>

  <div style="margin-top:1rem;">
    <div id="summary" class="counts muted"></div>
    <div class="bar"><span id="bar"></span></div>
    <div class="status">
      <strong id="phase">Idle</strong>
      <small id="detail"></small>
    </div>
  </div>

  <div id="results" style="margin-top:1rem;">
    <h2>Mods</h2>
    <div id="mods-table"></div>

    <h2>Resource Packs</h2>
    <div id="res-table"></div>

    <h2>Shaders</h2>
    <div id="shader-table"></div>
  </div>

  <div class="builder">
    <button id="build" disabled>Build updated .mrpack</button>
    <a id="downloadLink" class="small" style="display:none;">Download ready</a>
    <span id="buildNote" class="small muted"></span>
  </div>

  <details style="margin-top:1rem;">
    <summary>Raw results (debug)</summary>
    <pre id="raw"></pre>
  </details>

  <script src="./jszip-dist/jszip.min.js"></script>
  <script>
    const MAX_CONCURRENCY = 6;
    const $ = (id) => document.getElementById(id);

    const fileInput = $("file");
    const runBtn = $("run");
    const buildBtn = $("build");
    const dlLink = $("downloadLink");
    const buildNote = $("buildNote");

    const mcSelect = $("mc");
    const loaderSelect = $("loader");
    const outSummary = $("summary");
    const outRaw = $("raw");
    const bar = $("bar");
    const phase = $("phase");
    const detail = $("detail");

    const modsTable = $("mods-table");
    const resTable = $("res-table");
    const shaderTable = $("shader-table");

    let LAST_ROWS = [];        // rows from the last check (for builder)
    let LAST_INDEX = null;     // original modrinth.index.json
    let LAST_ZIP = null;       // original JSZip instance
    let LAST_TARGET_MC = "";   // target mc used
    let LAST_PACK_NAME = "";   // original pack name
    let PROJECTID_TO_ORIGFILE = new Map(); // project_id -> original file object (path/env/etc.)

    function setPhase(name, extra = "") {
      phase.textContent = name;
      detail.textContent = extra;
    }
    function setBar(current, total) {
      const pct = total ? Math.floor((current / total) * 100) : 0;
      bar.style.width = pct + "%";
    }
    function resetProgress() {
      setPhase("Idle");
      setBar(0, 1);
      outSummary.textContent = "";
    }

    // --- Populate MC versions dynamically ---
    (async function populateMcVersions(){
      try {
        mcSelect.disabled = true;
        mcSelect.innerHTML = `<option>Loading…</option>`;
        const res = await fetch("https://api.modrinth.com/v2/tag/game_version");
        if (!res.ok) throw new Error("Failed to fetch game versions");
        const tags = await res.json();

        const clean = tags
          .map(t => t.version || t)
          .filter(v => /^\d+\.\d+(\.\d+)?$/.test(v));

        clean.sort((a, b) => {
          const pa = a.split('.').map(n=>parseInt(n,10));
          const pb = b.split('.').map(n=>parseInt(n,10));
          while (pa.length < 3) pa.push(0);
          while (pb.length < 3) pb.push(0);
          for (let i=0;i<3;i++){ if (pb[i] !== pa[i]) return pb[i]-pa[i]; }
          return 0;
        });

        mcSelect.innerHTML = clean.map(v => `<option value="${v}">${v}</option>`).join("");
        mcSelect.disabled = false;
      } catch (e) {
        mcSelect.innerHTML = `<option value="1.21.4">1.21.4</option>`;
        mcSelect.disabled = false;
        console.warn("Falling back to static MC version list:", e);
      }
    })();

    // --- GitHub fallback for Fabric Carpet only ---
    function escReg(s) { return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); }

    async function fetchCarpetGitHubRelease(targetMc, { includePrereleases = false } = {}) {
      const res = await fetch("https://api.github.com/repos/gnembon/fabric-carpet/releases", {
        headers: {
          "Accept": "application/vnd.github+json",
          "User-Agent": "kris-mrpack-checker/1.0"
        }
      });
      if (!res.ok) return null;
      const releases = await res.json();
      const mcRe = new RegExp(`(^|\\b|-)${escReg(targetMc)}(\\b|-)`);
      for (const r of releases) {
        if (r.draft) continue;
        if (!includePrereleases && r.prerelease) continue;
        const asset = (r.assets || []).find(a =>
          /\.jar$/i.test(a.name) &&
          /fabric-?carpet/i.test(a.name) &&
          mcRe.test(a.name)
        );
        if (asset) {
          return {
            version_number: r.tag_name || asset.name,
            date_published: r.published_at || r.created_at || null,
            download_url: asset.browser_download_url,
            source: "github-fallback"
          };
        }
      }
      return null;
    }

    // --- Main flow (check) ---
    runBtn.addEventListener("click", async () => {
      const file = fileInput.files?.[0];
      if (!file) { alert("Choose a .mrpack (or .zip) first."); return; }
      const TARGET_MC = mcSelect.value;
      const PACK_LOADER = loaderSelect.value;

      resetProgress();
      modsTable.innerHTML = resTable.innerHTML = shaderTable.innerHTML = "";
      outRaw.textContent = "";
      buildBtn.disabled = true; dlLink.style.display = "none"; buildNote.textContent = "";

      try {
        setPhase("Reading pack…");
        const zipAb = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(zipAb);
        LAST_ZIP = zip;

        const indexFile = zip.file("modrinth.index.json");
        if (!indexFile) { setPhase("Error"); detail.textContent = "No modrinth.index.json"; return; }
        const index = JSON.parse(await indexFile.async("string"));
        LAST_INDEX = index;
        LAST_PACK_NAME = index?.name || "Updated Pack";

        const PACK_MC = index?.dependencies?.minecraft || "-";

        // collect sha1s and keep a mapping to original index file entries
        const sha1ToPath = new Map();
        const sha1s = [];
        const sha1ToFileObj = new Map();
        for (const f of index.files || []) {
          const sha1 = f?.hashes?.sha1;
          if (sha1) {
            sha1s.push(sha1);
            sha1ToPath.set(sha1, f.path || "");
            sha1ToFileObj.set(sha1, f);
          }
        }
        if (!sha1s.length) { setPhase("Done"); detail.textContent = "No file hashes in pack."; return; }

        outSummary.textContent = `Found ${sha1s.length} entries. Resolving projects…`;
        setBar(1, 5);

        // Step 2: hashes -> versions
        setPhase("Resolving versions from hashes…");
        const versionMap = await fetch("https://api.modrinth.com/v2/version_files", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ hashes: sha1s, algorithm: "sha1" })
        }).then(r => r.json());
        setBar(2, 5);

        // Step 3: collapse to unique projects and detect category, and remember original file obj per project
        setPhase("Collapsing to projects…");
        PROJECTID_TO_ORIGFILE = new Map();
        const projectEntries = new Map(); // project_id -> { anyVersion, exampleSha1, category }
        for (const [sha1, ver] of Object.entries(versionMap)) {
          if (!ver || !ver.project_id) continue;
          if (!projectEntries.has(ver.project_id)) {
            const path = sha1ToPath.get(sha1) || "";
            const category = path.startsWith("resourcepacks/") ? "resourcepack"
                           : path.startsWith("shaderpacks/")    ? "shaderpack"
                           : "mod";
            projectEntries.set(ver.project_id, { anyVersion: ver, exampleSha1: sha1, category });
            PROJECTID_TO_ORIGFILE.set(ver.project_id, sha1ToFileObj.get(sha1));
          }
        }
        const projectIds = [...projectEntries.keys()];
        if (!projectIds.length) {
          setPhase("Done"); detail.textContent = "No projects resolved."; outRaw.textContent = JSON.stringify(versionMap, null, 2); return;
        }
        setBar(3, 5);

        // Helpers
        function loaderForCategory(cat) {
          return (cat === "resourcepack" || cat === "shaderpack") ? "minecraft" : PACK_LOADER;
        }
        async function getProject(projectId) {
          const r = await fetch(`https://api.modrinth.com/v2/project/${projectId}`);
          if (!r.ok) return null;
          return r.json();
        }
        async function getBestTargetVersion(projectId, mc, loader) {
          const url = new URL(`https://api.modrinth.com/v2/project/${projectId}/version`);
          url.searchParams.set("game_versions", JSON.stringify([mc]));
          url.searchParams.set("loaders", JSON.stringify([loader]));
          const res = await fetch(url);
          if (!res.ok) throw new Error(`versions ${projectId}: ${res.status}`);
          const arr = await res.json();
          if (!Array.isArray(arr) || !arr.length) return null;
          const tier = v => v.version_type === "release" ? 3 : v.version_type === "beta" ? 2 : 1;
          arr.sort((a, b) => {
            const t = tier(b) - tier(a);
            if (t) return t;
            return new Date(b.date_published) - new Date(a.date_published);
          });
          return arr[0];
        }

        async function mapLimitProgress(items, limit, fn, onTick) {
          const out = new Array(items.length);
          let i = 0, done = 0;
          const running = new Set();
          async function run(idx) {
            const p = fn(items[idx]).then(v => out[idx] = v).finally(() => {
              running.delete(p);
              done++; onTick?.(done, items.length);
            });
            running.add(p);
            await p;
          }
          while (i < items.length) {
            while (running.size < limit && i < items.length) await run(i++);
            if (running.size) await Promise.race(running);
          }
          return out;
        }

        // Step 4: fetch project info + best target version, with progress (+ Carpet fallback only if Modrinth missing)
        setPhase("Checking target availability…", `0 / ${projectIds.length}`);
        const rows = await mapLimitProgress(
          projectIds,
          MAX_CONCURRENCY,
          async (pid) => {
            const rep = projectEntries.get(pid)?.anyVersion;
            const cat = projectEntries.get(pid)?.category || "mod";
            const loader = loaderForCategory(cat);
            const [proj, bestModrinth] = await Promise.all([
              getProject(pid),
              getBestTargetVersion(pid, TARGET_MC, loader)
            ]);

            let best = bestModrinth;
            let source = bestModrinth ? "modrinth" : "none";

            // Carpet fallback (only if Modrinth has no target build)
            const isCarpet = (proj?.slug === "fabric-carpet") || (pid === "TQTTVgYE");
            if (!bestModrinth && isCarpet) {
              const gh = await fetchCarpetGitHubRelease(TARGET_MC);
              if (gh) { best = gh; source = "github-fallback"; }
            }

            return {
              project_id: pid,
              category: cat,
              name: proj?.title || rep?.name || "(unknown)",
              slug: proj?.slug,
              current_version_number: rep?.version_number || "-",
              current_mc: PACK_MC,
              target_loader: loader,
              target_available: !!best,
              target_version_number: best?.version_number || "-",
              target_mc: TARGET_MC,
              target_date: best?.date_published || null,
              download_url: best?.files?.[0]?.url || best?.download_url || null,
              source
            };
          },
          (done, total) => {
            setPhase("Checking target availability…", `${done} / ${total}`);
            const stepBase = 3;
            const stepWidth = done / total;
            setBar(stepBase + stepWidth, 5);
          }
        );

        // Step 5: render & enable builder
        setPhase("Rendering results…");
        renderPartitionedTables(rows);
        outRaw.textContent = JSON.stringify(rows, null, 2);

        const total = rows.length;
        const have = rows.filter(r => r.target_available).length;
        outSummary.textContent = `Done. ${have}/${total} have a ${TARGET_MC} build.`;
        setBar(5, 5);
        setPhase("Done");

        LAST_ROWS = rows;
        LAST_TARGET_MC = TARGET_MC;
        buildBtn.disabled = false;
        buildNote.textContent = "You can now build a new .mrpack from the available Modrinth results.";
      } catch (err) {
        console.error(err);
        setPhase("Error", err?.message || String(err));
      }
    });

    function renderPartitionedTables(rows) {
      const mods = rows.filter(r => r.category === "mod");
      const res  = rows.filter(r => r.category === "resourcepack");
      const sh   = rows.filter(r => r.category === "shaderpack");
      $("mods-table").innerHTML   = renderTable(mods);
      $("res-table").innerHTML    = renderTable(res);
      $("shader-table").innerHTML = renderTable(sh);
    }

    function renderTable(rows) {
      if (!rows?.length) return `<div class="muted">No entries.</div>`;
      const targetMc = rows[0]?.target_mc || "(target)";
      const html = [
        "<table>",
        "<thead><tr>",
        "<th>Name</th>",
        "<th>Current mod</th>",
        "<th>Current MC</th>",
        "<th>Loader</th>",
        `<th>Has ${escapeHtml(targetMc)}</th>`,
        "<th>Target mod</th>",
        "<th>Source</th>",
        "<th>Published</th>",
        "<th>Download</th>",
        "</tr></thead><tbody>",
        ...rows.map(r => {
          const ok = r.target_available;
          const date = r.target_date ? new Date(r.target_date).toLocaleDateString() : "-";
          const dl = r.download_url ? `<a href="${r.download_url}" target="_blank" rel="noreferrer">.jar</a>` : "";
          const sourceBadge =
            r.source === "github-fallback"
              ? `<span class="badge github-fallback" title="Found on GitHub because Modrinth had no ${escapeHtml(r.target_mc)} build">GitHub fallback</span>`
              : r.source === "modrinth"
                ? `<span class="badge modrinth" title="Found on Modrinth">Modrinth</span>`
                : `<span class="badge" title="No match">–</span>`;
          return `<tr>
            <td>${escapeHtml(r.name || "(unknown)")}</td>
            <td>${escapeHtml(r.current_version_number)}</td>
            <td>${escapeHtml(r.current_mc)}</td>
            <td>${escapeHtml(r.target_loader || "-")}</td>
            <td class="${ok ? "ok" : "no"}">${ok ? "✅" : "❌"}</td>
            <td>${escapeHtml(r.target_version_number)}</td>
            <td>${sourceBadge}</td>
            <td>${date}</td>
            <td>${dl}</td>
          </tr>`;
        }),
        "</tbody></table>"
      ].join("");
      return html;
    }

    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, c => ({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
    }

    // ===== MRPACK BUILDER =====
    buildBtn.addEventListener("click", async () => {
      if (!LAST_ROWS.length || !LAST_INDEX || !LAST_ZIP) {
        alert("Run a check first.");
        return;
      }

      buildBtn.disabled = true;
      dlLink.style.display = "none";
      buildNote.textContent = "Building .mrpack… (fetching jars to compute hashes)";

      try {
        // Only include rows that have a target build from Modrinth (reliable CORS)
        const includable = LAST_ROWS.filter(r => r.target_available && r.source === "modrinth" && r.download_url);

        // Fetch jars, compute sha512 & sha1, and record sizes
        const fileRecords = [];
        let done = 0;
        setPhase("Downloading & hashing jars…", `0 / ${includable.length}`);
        for (const row of includable) {
          const url = row.download_url;
          const resp = await fetch(url);
          if (!resp.ok) throw new Error(`Failed to fetch ${url}`);
          const buf = await resp.arrayBuffer();
          const size = buf.byteLength;
          const sha512 = await digestHex("SHA-512", buf);
          const sha1   = await digestHex("SHA-1", buf);

          // Preserve original file path + env from index where possible
          const of = PROJECTID_TO_ORIGFILE.get(row.project_id) || {};
          const path = of.path || inferPathFromCategory(row);
          const env  = of.env || { client: "required", server: "required" };

          fileRecords.push({
            path,
            hashes: { sha512, sha1 },
            env,
            downloads: [url],
            fileSize: size
          });

          done++; setPhase("Downloading & hashing jars…", `${done} / ${includable.length}`);
          setBar(3 + (done / Math.max(includable.length,1)), 5); // reuse bar scale
        }

        // Build new index: clone old, bump MC, replace files
        const newIndex = structuredClone(LAST_INDEX);
        newIndex.dependencies = Object.assign({}, newIndex.dependencies, { minecraft: LAST_TARGET_MC });
        newIndex.name = `${(LAST_PACK_NAME || "Pack").replace(/\s+$/, "")} (for ${LAST_TARGET_MC})`;
        newIndex.files = fileRecords;

        // Assemble new ZIP: copy overrides/ from original, add new index
        setPhase("Packaging mrpack…");
        const outZip = new JSZip();

        // Copy overrides/ (if present) 1:1
        const overrideEntries = Object.values(LAST_ZIP.files).filter(e => e.name.startsWith("overrides/") && !e.dir);
        for (const e of overrideEntries) {
          const content = await LAST_ZIP.file(e.name).async("arraybuffer");
          outZip.file(e.name, content);
        }

        // Write modrinth.index.json
        outZip.file("modrinth.index.json", JSON.stringify(newIndex, null, 2));

        const blob = await outZip.generateAsync({ type: "blob" });
        const fileName = `${slugify(newIndex.name)}.mrpack`;

        // Download link
        const url = URL.createObjectURL(blob);
        dlLink.href = url;
        dlLink.download = fileName;
        dlLink.textContent = `Download ${fileName}`;
        dlLink.style.display = "inline";
        buildNote.innerHTML = buildWarningNote(LAST_ROWS);

        setPhase("Done");
      } catch (e) {
        console.error(e);
        buildNote.textContent = `Build failed: ${e.message || e}`;
        setPhase("Error", e.message || String(e));
      } finally {
        buildBtn.disabled = false;
      }
    });

    function buildWarningNote(rows) {
      const skipped = rows.filter(r => r.target_available && r.source !== "modrinth");
      if (!skipped.length) return "Built from all available Modrinth versions.";
      const names = skipped.map(r => r.name || r.slug || r.project_id).join(", ");
      return `Built pack excludes ${skipped.length} item(s) without Modrinth-downloadable jars (e.g. GitHub fallback): ` +
             `<span class="warn">${escapeHtml(names)}</span>`;
    }

    function inferPathFromCategory(row) {
      if (row.category === "resourcepack") return `resourcepacks/${(row.slug || "resourcepack")}.zip`;
      if (row.category === "shaderpack")   return `shaderpacks/${(row.slug || "shaderpack")}.zip`;
      return `mods/${(row.slug || "mod")}.jar`;
    }

    async function digestHex(algo, buf) {
      const h = await crypto.subtle.digest(algo, buf);
      return [...new Uint8Array(h)].map(b => b.toString(16).padStart(2, "0")).join("");
    }

    function slugify(s) {
      return String(s).toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-+|-+$/g, "")
        .slice(0, 80);
    }
  </script>
</body>
</html>